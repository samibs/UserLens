// examples/plugins/userlens-generator-html/src/html-generator.ts
import * as fs from 'fs/promises';
import * as path from 'path';
import { 
    ComponentMetadata, 
    DocumentGenerator, 
    UserJourney 
} from '../../../../src/models/interfaces'; // Adjust path
import { PluginConfig, UserLensCoreApi, LoggerInterface } from '../../../../src/models/plugin-interfaces'; // Adjust path

interface NavLink {
  href: string;
  text: string;
  isActive?: boolean;
}

// Placeholder for WorkflowPattern if not defined in core interfaces for MVP
interface WorkflowPattern {
  name: string;
  description: string;
  steps?: string[]; // Or a more complex structure for steps
}

export class HtmlGenerator implements DocumentGenerator {
  private config?: PluginConfig;
  private coreApi?: UserLensCoreApi;
  private logger: LoggerInterface;

  constructor(config?: PluginConfig, coreApi?: UserLensCoreApi) {
    this.config = config;
    this.coreApi = coreApi;
    this.logger = coreApi?.getLogger('HtmlGenerator') || {
      info: console.log,
      warn: console.warn,
      error: console.error
    };
    this.logger.info('HtmlGenerator instance created.');
    if (this.config?.theme) {
        this.logger.info(`Using theme: ${this.config.theme}`);
    }
  }

  private sanitizeHtml(text: string | undefined): string {
    if (!text) return '';
    return text.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>').replace(/"/g, '"').replace(/'/g, '&#039;');
  }

  private generateUrlFriendlyName(name: string): string {
    if (!name) return 'untitled';
    return name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
  }

  private generateHtmlShell(title: string, content: string, relativePathToRoot: string, currentHref?: string): string {
    const baseNavLinks: NavLink[] = [
      { href: 'index.html', text: 'Home' },
      { href: 'overview.html', text: 'Overview' },
      { href: 'getting-started/index.html', text: 'Getting Started' },
      { href: 'features/index.html', text: 'Features' },
      { href: 'workflows/index.html', text: 'Workflows' },
    ];

    const navLinksHtml = baseNavLinks.map(link => {
      const isActive = currentHref === link.href || (currentHref?.startsWith(link.href.replace('index.html', '')) && link.href.endsWith('index.html'));
      return `<li${isActive ? ' style="font-weight:bold;"' : ''}><a href="${relativePathToRoot}${link.href}">${link.text}</a></li>`;
    }).join('');

    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${this.sanitizeHtml(title)} - UserLens Docs</title>
    <link rel="stylesheet" href="${relativePathToRoot}assets/style.css">
</head>
<body>
    <header>
        <h1>UserLens Generated Documentation</h1>
    </header>
    <div class="main-container">
        <nav>
            <ul>${navLinksHtml}</ul>
        </nav>
        <main>
            <article>
                <h1>${this.sanitizeHtml(title)}</h1>
                ${content}
            </article>
        </main>
    </div>
    <footer>
        <p>Generated by UserLens HTML Generator</p>
    </footer>
</body>
</html>`;
  }

  async generateDocumentation(
    components: ComponentMetadata[],
    journeys: UserJourney[],
    outputPath: string
  ): Promise<void> {
    this.logger.info(`HTML Generator: Generating documentation at ${outputPath}`);
    await fs.mkdir(outputPath, { recursive: true });
    
    const assetsPath = path.join(outputPath, 'assets');
    await fs.mkdir(assetsPath, { recursive: true });
    await this.copyAssets(assetsPath);

    await this.generateIndexPage(outputPath, components, journeys);
    await this.generateOverviewPage(outputPath, components, journeys);
    await this.generateGettingStartedPages(outputPath, components, journeys);
    await this.generateFeaturesPages(outputPath, components);
    // For MVP, generateWorkflowsPage will use placeholder data or derive from components if simple.
    // The signature from the task is (outputPath, components)
    await this.generateWorkflowsPage(outputPath, components);

    this.logger.info('HTML Generator: Full documentation generation complete.');
  }
  
  private async copyAssets(assetsPath: string): Promise<void> {
    const defaultCss = `
      body { font-family: sans-serif; margin: 0; padding: 0; display: flex; min-height: 100vh; flex-direction: column; }
      nav { width: 250px; background: #f4f4f4; padding: 1em; border-right: 1px solid #ddd; flex-shrink: 0; }
      nav ul { list-style: none; padding: 0; }
      nav ul li a { text-decoration: none; color: #333; display: block; padding: 0.5em 0; }
      .main-container { display: flex; flex-grow: 1; }
      main { padding: 1em; flex-grow: 1; }
      header { background: #333; color: white; padding: 1em; text-align: center; }
      .component-card { border: 1px solid #eee; padding: 1em; margin-bottom: 1em; }
      footer { background: #333; color: white; text-align: center; padding: 1em; margin-top: auto; }
      table { border-collapse: collapse; width: 100%; margin-bottom: 1em; }
      th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
      th { background-color: #f2f2f2; }
    `;
    try {
      await fs.writeFile(path.join(assetsPath, 'style.css'), defaultCss);
      this.logger.info('HTML Generator: Default style.css copied to assets.');
    } catch (error) {
      this.logger.error(`HTML Generator: Error copying assets: ${error}`);
      // Re-throw or handle as per plugin error strategy
      if (error instanceof Error) {
        throw new Error(`Failed to copy assets: ${error.message}`);
      }
      throw new Error('Failed to copy assets due to an unknown error.');
    }
  }

  private async generateIndexPage(outputPath: string, components: ComponentMetadata[], journeys: UserJourney[]): Promise<void> {
    const pageTitle = 'Home';
    const content = `
      <p>Welcome to the UserLens generated documentation.</p>
      <p>This site provides an overview of the application's components, features, and user workflows.</p>
      <h2>Quick Links</h2>
      <ul>
        <li><a href="overview.html">Application Overview</a></li>
        <li><a href="getting-started/index.html">Getting Started Guide</a></li>
        <li><a href="features/index.html">Features and Components</a></li>
        <li><a href="workflows/index.html">User Workflows</a></li>
      </ul>
      <p>Found ${components.length} components and ${journeys.length} user journeys.</p>
    `;
    const html = this.generateHtmlShell(pageTitle, content, '', 'index.html');
    await fs.writeFile(path.join(outputPath, 'index.html'), html);
    this.logger.info('Generated index.html');
  }

  private async generateOverviewPage(outputPath: string, components: ComponentMetadata[], journeys: UserJourney[]): Promise<void> {
    const pageTitle = 'Application Overview';
    // Simple overview, can be expanded with summaries from components/journeys
    let content = `<p>This section provides a high-level overview of the application.</p>`;
    
    content += `<h2>Key Information</h2>`;
    content += `<ul>`;
    content += `<li>Total Components Documented: ${components.length}</li>`;
    content += `<li>Total User Journeys Analyzed: ${journeys.length}</li>`;
    content += `</ul>`;

    if (journeys.length > 0) {
      content += `<h2>Primary User Journeys</h2><ul>`;
      journeys.slice(0, 5).forEach(journey => { // Display first 5 journeys as example
        content += `<li><strong>${this.sanitizeHtml(journey.name)}:</strong> ${this.sanitizeHtml(journey.description)}</li>`;
      });
      content += `</ul>`;
    }

    const html = this.generateHtmlShell(pageTitle, content, '', 'overview.html');
    await fs.writeFile(path.join(outputPath, 'overview.html'), html);
    this.logger.info('Generated overview.html');
  }

  private async generateGettingStartedPages(outputPath: string, components: ComponentMetadata[], journeys: UserJourney[]): Promise<void> {
    const gsPath = path.join(outputPath, 'getting-started');
    await fs.mkdir(gsPath, { recursive: true });

    const relativePathToRoot = '../';

    // Getting Started Index
    const indexContent = `
      <p>This guide helps new users get started with the application.</p>
      <ul>
        <li><a href="authentication.html">Authentication</a></li>
        <li><a href="navigation.html">Navigation Basics</a></li>
        <li><a href="first-steps.html">First Steps</a></li>
      </ul>
    `;
    const indexHtml = this.generateHtmlShell('Getting Started', indexContent, relativePathToRoot, 'getting-started/index.html');
    await fs.writeFile(path.join(gsPath, 'index.html'), indexHtml);

    // Authentication Page
    const authContent = `<p>Details about application authentication. (Placeholder)</p>`;
    const authHtml = this.generateHtmlShell('Authentication', authContent, relativePathToRoot, 'getting-started/authentication.html');
    await fs.writeFile(path.join(gsPath, 'authentication.html'), authHtml);

    // Navigation Page
    const navContent = `<p>How to navigate the application. (Placeholder)</p>`;
    const navHtml = this.generateHtmlShell('Navigation', navContent, relativePathToRoot, 'getting-started/navigation.html');
    await fs.writeFile(path.join(gsPath, 'navigation.html'), navHtml);

    // First Steps Page
    const firstStepsContent = `<p>Guide to performing initial tasks. (Placeholder)</p>`;
    const firstStepsHtml = this.generateHtmlShell('First Steps', firstStepsContent, relativePathToRoot, 'getting-started/first-steps.html');
    await fs.writeFile(path.join(gsPath, 'first-steps.html'), firstStepsHtml);

    this.logger.info('Generated getting-started pages.');
  }

  private async generateFeaturesPages(outputPath: string, components: ComponentMetadata[]): Promise<void> {
    const featuresPath = path.join(outputPath, 'features');
    await fs.mkdir(featuresPath, { recursive: true });

    const relativePathToRoot = '../';

    const categories: { [key: string]: ComponentMetadata[] } = {};
    components.forEach(comp => {
      const category = comp.semanticCategory || 'Uncategorized';
      if (!categories[category]) {
        categories[category] = [];
      }
      categories[category].push(comp);
    });

    let featuresIndexContent = `<p>This section details the application's features, organized by category.</p><ul>`;
    for (const categoryName in categories) {
      const categorySlug = this.generateUrlFriendlyName(categoryName);
      featuresIndexContent += `<li><a href="${categorySlug}/index.html">${this.sanitizeHtml(categoryName)}</a> (${categories[categoryName].length} components)</li>`;
      
      const categoryPath = path.join(featuresPath, categorySlug);
      await fs.mkdir(categoryPath, { recursive: true });
      
      await this.generateCategoryOverviewPage(categoryPath, categoryName, categories[categoryName], '../../');

      for (const component of categories[categoryName]) {
        await this.generateComponentPage(categoryPath, component, '../../');
      }
    }
    featuresIndexContent += `</ul>`;

    const featuresIndexHtml = this.generateHtmlShell('Features', featuresIndexContent, relativePathToRoot, 'features/index.html');
    await fs.writeFile(path.join(featuresPath, 'index.html'), featuresIndexHtml);
    this.logger.info('Generated features pages.');
  }

  private async generateCategoryOverviewPage(categoryPath: string, categoryName: string, categoryComponents: ComponentMetadata[], relativePathToRoot: string): Promise<void> {
    const pageTitle = `${categoryName} Components`;
    let content = `<p>Overview of components in the ${this.sanitizeHtml(categoryName)} category.</p><ul>`;
    categoryComponents.forEach(comp => {
      const componentSlug = this.generateUrlFriendlyName(comp.name);
      content += `<li><a href="${componentSlug}.html">${this.sanitizeHtml(comp.name)}</a>: ${this.sanitizeHtml(comp.description?.substring(0,100))}...</li>`;
    });
    content += `</ul>`;

    const html = this.generateHtmlShell(pageTitle, content, relativePathToRoot, `features/${this.generateUrlFriendlyName(categoryName)}/index.html`);
    await fs.writeFile(path.join(categoryPath, 'index.html'), html);
    this.logger.info(`Generated category overview for ${categoryName}`);
  }

  private async generateComponentPage(componentBasePath: string, component: ComponentMetadata, relativePathToRoot: string): Promise<void> {
    const pageTitle = component.name;
    let content = `<p>${this.sanitizeHtml(component.description)}</p>`;

    if (component.props && Object.keys(component.props).length > 0) {
      content += `<h2>Properties</h2><table><thead><tr><th>Name</th><th>Type</th><th>Required</th><th>Default</th><th>Description</th></tr></thead><tbody>`;
      for (const propName in component.props) {
        const prop = component.props[propName];
        content += `<tr>
          <td>${this.sanitizeHtml(prop.name)}</td>
          <td>${this.sanitizeHtml(prop.type)}</td>
          <td>${prop.required ? 'Yes' : 'No'}</td>
          <td>${this.sanitizeHtml(prop.defaultValue)}</td>
          <td>${this.sanitizeHtml(prop.description)}</td>
        </tr>`;
      }
      content += `</tbody></table>`;
    }

    if (component.userActions && component.userActions.length > 0) {
      content += `<h2>User Actions</h2><ul>`;
      component.userActions.forEach(action => {
        content += `<li><strong>${this.sanitizeHtml(action.trigger)}:</strong> ${this.sanitizeHtml(action.description)}</li>`;
      });
      content += `</ul>`;
    }

    const componentSlug = this.generateUrlFriendlyName(component.name);
    const categorySlug = this.generateUrlFriendlyName(component.semanticCategory || 'uncategorized');
    const html = this.generateHtmlShell(pageTitle, content, relativePathToRoot, `features/${categorySlug}/${componentSlug}.html`);
    await fs.writeFile(path.join(componentBasePath, `${componentSlug}.html`), html);
    this.logger.info(`Generated component page for ${component.name}`);
  }

  private async generateWorkflowsPage(outputPath: string, components: ComponentMetadata[]): Promise<void> {
    const workflowsPath = path.join(outputPath, 'workflows');
    await fs.mkdir(workflowsPath, { recursive: true });
    const relativePathToRoot = '../';

    // MVP: Placeholder workflows. In future, derive from journeys or PatternMatcher.
    const placeholderWorkflows: WorkflowPattern[] = [
      { name: 'User Registration', description: 'Process for new users to sign up.', steps: ['Fill registration form', 'Verify email', 'Set password'] },
      { name: 'Password Reset', description: 'Process for users to reset their forgotten password.', steps: ['Enter email', 'Click reset link in email', 'Set new password'] }
    ];

    let workflowsIndexContent = `<p>This section describes common user workflows in the application.</p><ul>`;
    for (const workflow of placeholderWorkflows) {
      const workflowSlug = this.generateUrlFriendlyName(workflow.name);
      workflowsIndexContent += `<li><a href="${workflowSlug}.html">${this.sanitizeHtml(workflow.name)}</a></li>`;
      await this.generateWorkflowDetailPage(workflowsPath, workflow, '../../');
    }
    workflowsIndexContent += `</ul>`;

    const html = this.generateHtmlShell('User Workflows', workflowsIndexContent, relativePathToRoot, 'workflows/index.html');
    await fs.writeFile(path.join(workflowsPath, 'index.html'), html);
    this.logger.info('Generated workflows pages.');
  }

  private async generateWorkflowDetailPage(workflowPath: string, workflow: WorkflowPattern, relativePathToRoot: string): Promise<void> {
    const pageTitle = workflow.name;
    let content = `<p>${this.sanitizeHtml(workflow.description)}</p>`;
    if (workflow.steps && workflow.steps.length > 0) {
      content += `<h2>Steps:</h2><ol>`;
      workflow.steps.forEach(step => {
        content += `<li>${this.sanitizeHtml(step)}</li>`;
      });
      content += `</ol>`;
    } else {
      content += `<p>Detailed steps for this workflow are not yet documented.</p>`;
    }

    const workflowSlug = this.generateUrlFriendlyName(workflow.name);
    const html = this.generateHtmlShell(pageTitle, content, relativePathToRoot, `workflows/${workflowSlug}.html`);
    await fs.writeFile(path.join(workflowPath, `${workflowSlug}.html`), html);
    this.logger.info(`Generated workflow detail page for ${workflow.name}`);
  }
}